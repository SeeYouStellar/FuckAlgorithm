很巧秒的做法。最后的T=O(nlogn)，S=O(1)。

首先题目要求不能原地修改数组，不能使用额外空间。

那么自然就是二分搜索，这题的难点在于又是一道找不到搜索目标的题

首先既然要二分，数组肯定得是单调的，很明显题目给的nums是不单调的，并且是随机的，不能看作二分的对象。（这与1802山峰数组不同）

那就另外找数组，很显然，T=O(n)，S=O(n)的解法是用hash表记录每个数出现的频率，那么针对这道题，这种hash明显是不单调的，但是累计的hash是单调的。

只有一个数有重复，数字范围从1~n

对于nums = [1,3,4,3,3]，3是重复数

那么cnt表就是：

| index                                 | 1    | 2    | 3    | 4    |
| ------------------------------------- | ---- | ---- | ---- | ---- |
| cnt(index) = (<=index的数 出现的次数) | 1    | 1    | 4    | 5    |

很显然，cnt表是单调的。那么很好，能用二分了。

接下来就是找二分的目标，很显然cnt表在2之前满足$cnt[i]<=i$，而在2之后包括2，满足$cnt[i]>i$。二分的约束条件找到。

接下来还有一个问题就是不允许有额外空间，那么就用时间去凑。每次搜索时查找真个nums中小于等于下标mid的元素个数。总时间O(nlogn)。

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int l = 1, r = nums.size()-2;
        while(l<=r) {
            int mid = (l+r)>>1;
            int cnt = 0;
            for(int i=0;i<nums.size();i++){
                cnt += nums[i]<=mid;
            }
            if(cnt>mid) r = mid-1;
            else l = mid+1;
        }
        return l;
    }
};
```



## 总结：

有重复数字，那么就得想到如果数组单调就直接用二分，如果数组无序，那么他的累计个数数组是单调的。

二分的题难点永远在于找到一个单调的数组，并确定约束条件！
